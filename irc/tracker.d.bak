module irc.tracker;

import irc.client;
import irc.util : ExceptionConstructor;

import std.exception : enforce;
import std.traits : Unqual;
import std.typetuple : TypeTuple;
import std.algorithm : canFind, countUntil, remove, SwapStrategy;
import std.string : toUpper;
import std.array;
import std.conv : to;

///
class IrcTrackingException : Exception
{
    mixin ExceptionConstructor!();
}

/// Mode prefix mapping and priority (higher = shown)
private immutable int[char] prefixPriority = [
    '@': 3,
    '+': 1,
    '%': 2,
    '&': 4,
    '~': 5
];

// Mode to prefix mapping (from IRC mode char to display prefix)
private immutable char[char] modeToPrefix = [
    'q': '~',  // owner
    'a': '&',  // admin
    'o': '@',  // operator
    'h': '%',  // halfop
    'v': '+'   // voice
];

// Prefix to mode mapping (reverse lookup)
private immutable char[char] prefixToMode = [
    '~': 'q',
    '&': 'a',
    '@': 'o',
    '%': 'h',
    '+': 'v'
];

/**
 * Create a new channel and user tracking object for the given
 * $(DPREF _client, IrcClient). Tracking for the new object
 * is initially disabled; use $(MREF IrcTracker.start) to commence tracking.
 *
 * Params:
 *   Payload = type of extra storage per $(MREF TrackedUser) object
 * See_Also:
 *    $(MREF IrcTracker), $(MREF TrackedUser.payload)
 */
CustomIrcTracker!Payload track(Payload = void)(IrcClient client)
{
    return new typeof(return)(client);
}

/**
 * Represents an IRC user for use by $(MREF IrcTracker).
 */
struct TrackedUser
{
    private:
    this(string nickName)
    {
        this.nickName = nickName;
    }

    public:
    @disable this();

    /**
     * Nick name, user name and host name of the _user.
     *
     * $(D TrackedUser) is a super-type of $(DPREF protocol, IrcUser).
     *
     * Only the nick name is guaranteed to be non-null.
     * See_Also:
     *   $(DPREF protocol, IrcUser)
     */
    IrcUser user;

    /// Ditto
    alias user this;

    /**
     * Real name of the user. Is $(D null) unless a whois-query
     * has been successfully issued for the user.
     *
     * See_Also:
     *   $(DPREF client, IrcClient.queryWhois)
     */
    string realName;

    /**
     * Channels in which both the current user and the tracked
     * user share membership.
     *
     * See_Also:
     * $(DPREF client, IrcClient.queryWhois) to query channels
     * a user is in, regardless of shared membership with the current user.
     */
    string[] channels;

    /**
     * Channel -> array of ALL prefix chars user has in that channel.
     * NEW: Mode tracking support.
     */
    char[][string] channelPrefixes;

    /**
     * Get highest priority prefix for display in given channel.
     * Returns '\0' if user has no prefix in that channel.
     */
    char getHighestPrefix(in char[] channel) const
    {
        if (auto prefixesPtr = channel in channelPrefixes)
        {
            char highest = '\0';
            int highestPrio = 0;

            foreach (prefix; *prefixesPtr)
            {
                int prio = prefixPriority.get(prefix, 0);
                if (prio > highestPrio)
                {
                    highest = prefix;
                    highestPrio = prio;
                }
            }

            return highest;
        }
        return '\0';
    }

    /// Check if user has a specific prefix in channel
    bool hasPrefix(in char[] channel, char prefix) const
    {
        if (auto prefixesPtr = channel in channelPrefixes)
        {
            return canFind(*prefixesPtr, prefix);
        }
        return false;
    }

    /// Add a prefix to user in channel
    void addPrefix(in char[] channel, char prefix)
    {
        if (!(channel in channelPrefixes))
        {
            channelPrefixes[channel] = [];
        }

        if (!hasPrefix(channel, prefix))
        {
            channelPrefixes[channel] ~= prefix;
        }
    }

    /// Remove a prefix from user in channel
    void removePrefix(in char[] channel, char prefix)
    {
        if (auto prefixesPtr = channel in channelPrefixes)
        {
            char[] prefixes = *prefixesPtr;
            char[] newPrefixes;

            foreach (p; prefixes)
            {
                if (p != prefix)
                {
                    newPrefixes ~= p;
                }
            }

            channelPrefixes[channel] = newPrefixes;

            if (newPrefixes.length == 0)
            {
                // Convert to string for removal
                channelPrefixes.remove(channel.to!string);
            }
        }
    }

    /// Get all prefixes user has in channel
    char[] getAllPrefixes(in char[] channel) const
    {
        if (auto prefixesPtr = channel in channelPrefixes)
        {
            return (*prefixesPtr).dup;
        }
        return [];
    }

    void toString(scope void delegate(const(char)[]) @safe sink) const
    {
        import std.format;
        user.toString(sink);

        if(realName)
        {
            sink("$");
            sink(realName);
        }

        formattedWrite(sink, "(%(%s%|,%))", channels);
    }
}

/**
 * Represents an IRC user for use by $(MREF CustomIrcTracker).
 * Params:
 *   Payload = type of extra storage per $(MREF TrackedUser) object
 * See_Also:
 *   $(MREF CustomTrackedUser.payload)
 */
align(1) struct CustomTrackedUser(Payload)
{
    /// $(D CustomTrackedUser) is a super-type of $(MREF TrackedUser).
    TrackedUser user;

    /// Ditto
    alias user this;

    /**
     * Extra data attached to this user for per-application data.
     */
    Payload payload;

    ///
    this(string nickName)
    {
        user = TrackedUser(nickName);
    }
}

///
alias CustomTrackedUser(Payload : void) = TrackedUser;

/**
 * Represents an IRC channel and its member users for use by $(MREF IrcTracker).
 *
 * The list of members includes the user associated with the tracking object.
 * If the $(D IrcTracker) used to access an instance of this type
 * was since stopped, the channel presents the list of members as it were
 * at the time of the tracker being stopped.
 *
 * Params:
 *   Payload = type of extra storage per $(MREF TrackedUser) object
 * See_Also:
 *   $(MREF CustomTrackedUser.payload)
 */
struct CustomTrackedChannel(Payload = void)
{
    private:
    string _name;
    CustomTrackedUser!Payload*[string] _users;

    this(string name, CustomTrackedUser!Payload*[string] users = null)
    {
        _name = name;
        _users = users;
    }

    public:
    @disable this();

    /// Name of the channel, including the channel prefix.
    string name() @property
    {
        return _name;
    }

    /// $(D InputRange) of all member _users of this channel,
    /// where each user is given as a $(D (MREF TrackedUser)*).
    auto users() @property
    {
        import std.range : takeExactly;
        return _users.byValue.takeExactly(_users.length);
    }

    /**
     * Lookup a member of this channel by nick name.
     * $(D null) is returned if the given nick is not a member
     * of this channel.
     * Params:
     *   nick = nick name of member to lookup
     */
    CustomTrackedUser!Payload* opBinary(string op : "in")(in char[] nick)
    {
        enforce(cast(bool)this, "the TrackedChannel is invalid");
        if(auto pUser = nick in _users)
            return *pUser;
        else
            return null;
    }

    static if(!is(Payload == void))
    {
        TrackedChannel erasePayload() @property
        {
            return TrackedChannel(_name, cast(TrackedUser*[string])_users);
        }

        alias erasePayload this;
    }
}

/// Ditto
alias TrackedChannel = CustomTrackedChannel!void;

/**
 * Keeps track of all channels and channel members
 * visible to the associated $(DPREF client, IrcClient) connection.
 *
 * Params:
 *   Payload = type of extra storage per $(MREF TrackedUser) object
 * See_Also:
 *   $(MREF CustomTrackedUser.payload)
 */
class CustomIrcTracker(Payload = void)
{
    private:
    IrcClient _client;
    CustomTrackedChannel!Payload[string] _channels;
    CustomTrackedUser!Payload*[string] _users;
    CustomTrackedUser!Payload* thisUser;

    enum State { disabled, starting, enabled }
    auto _isTracking = State.disabled;

    debug(IrcTracker) import std.stdio;

    final:
    debug(IrcTracker) void checkIntegrity()
    {
        import std.algorithm;

        if(!isTracking)
        {
            assert(channels.empty);
            assert(_channels is null);
            assert(_users is null);
            return;
        }

        foreach(channel; channels)
        {
            assert(channel.name.length != 0);
            assert(channel.users.length != 0);
            foreach(member; channel.users)
            {
                auto user = findUser(member.nickName);
                assert(user);
                assert(user == member);
            }
        }

        assert(thisUser == _users[thisUser.nickName]);

        foreach(user; users)
            if(user != thisUser)
                assert(channels.map!(chan => chan.users).joiner().canFind(user), "unable to find " ~ user.nickName ~ " in any channels");
    }

    void onConnect()
    {
        thisUser.nickName = _client.nickName.to!string;
        thisUser.userName = _client.userName.to!string;
        thisUser.realName = _client.realName.to!string;

        debug(IrcTracker) writeln("tracker connected; thisUser = ", *thisUser);
    }

    void onSuccessfulJoin(in char[] channelName)
    {
        debug(IrcTracker)
        {
            writeln("onmejoin: ", channelName);
            checkIntegrity();
        }

        auto channel = CustomTrackedChannel!Payload(channelName.idup);
        channel._users = [_client.nickName.to!string: thisUser];
        _channels[channel.name] = channel;

        debug(IrcTracker)
        {
            write("checking... ");
            checkIntegrity();
            writeln("done.");
        }
    }

    void onNameList(in char[] channelName, in char[][] nickNames)
    {
        debug(IrcTracker)
        {
            writefln("names %s: %(%s%|, %)", channelName, nickNames);
            checkIntegrity();
        }

        auto channel = _channels[channelName];

        foreach(nickName; nickNames)
        {
            // Strip prefix from NAMES (some servers send @nick, +nick)
            string nick = nickName.to!string;
            char prefix = '\0';

            if (nick.length > 0)
            {
                char first = nick[0];
                if (first in prefixPriority)
                {
                    prefix = first;
                    nick = nick[1 .. $].to!string;  // Convert sliced portion to string
                }
            }

            if(auto pUser = nick in _users)
            {
                auto user = *pUser;
                user.channels ~= channel.name;
                channel._users[cast(immutable)nick] = user;

                // Apply prefix from NAMES if present
                if (prefix != '\0')
                {
                    user.addPrefix(channel.name, prefix);
                }
            }
            else
            {
                auto immNick = nick;

                auto user = new CustomTrackedUser!Payload(immNick);
                user.channels = [channel.name];

                // Apply prefix from NAMES if present
                if (prefix != '\0')
                {
                    user.addPrefix(channel.name, prefix);
                }

                channel._users[immNick] = user;
                _users[immNick] = user;
            }
        }

        debug(IrcTracker)
        {
            import std.algorithm : map;
            writeln(channel._users.values.map!(user => *user));
            write("checking... ");
            checkIntegrity();
            writeln("done.");
        }
    }

    void onJoin(IrcUser user, in char[] channelName)
    {
        debug(IrcTracker)
        {
            writefln("%s joined %s", user.nickName, channelName);
            checkIntegrity();
        }

        auto channel = _channels[channelName];

        if(auto pUser = user.nickName.to!string in _users)
        {
            auto storedUser = *pUser;
            if(!storedUser.userName)
                storedUser.userName = user.userName.idup;
            if(!storedUser.hostName)
                storedUser.hostName = user.hostName.idup;

            storedUser.channels ~= channel.name;
            channel._users[user.nickName.to!string] = storedUser;
        }
        else
        {
            auto immNick = user.nickName.idup;
            auto newUser = new CustomTrackedUser!Payload(immNick);
            newUser.userName = user.userName.idup;
            newUser.hostName = user.hostName.idup;
            newUser.channels = [channel.name];

            _users[immNick] = newUser;
            channel._users[immNick] = newUser;
        }

        debug(IrcTracker)
        {
            write("checking... ");
            checkIntegrity();
            writeln("done.");
        }
    }

    // Utility function
    void onMeLeave(in char[] channelName)
    {
        import std.algorithm : countUntil, remove, SwapStrategy;

        debug(IrcTracker)
        {
            writeln("onmeleave: ", channelName);
            checkIntegrity();
        }

        auto channel = _channels[channelName];

        foreach(ref user; channel._users)
        {
            auto channelIndex = user.channels.countUntil(channelName.to!string);
            assert(channelIndex != -1);
            user.channels = user.channels.remove!(SwapStrategy.unstable)(channelIndex);
            if(user.channels.length == 0 && user.nickName != client.nickName)
                _users.remove(user.nickName.to!string);
        }

        _channels.remove(channelName.to!string);

        debug(IrcTracker)
        {
            write("checking... ");
            checkIntegrity();
            writeln("done.");
        }
    }

    // Utility function
    void onLeave(in char[] channelName, in char[] nick)
    {
        import std.algorithm : countUntil, remove, SwapStrategy;

        debug(IrcTracker)
        {
            writefln("%s left %s", nick, channelName);
            checkIntegrity();
        }

        string nickStr = nick.to!string;
        string channelStr = channelName.to!string;

        _channels[channelStr]._users.remove(nickStr);

        auto pUser = nickStr in _users;
        if (pUser)
        {
            auto user = *pUser;
            auto channelIndex = user.channels.countUntil(channelStr);
            assert(channelIndex != -1);
            user.channels = user.channels.remove!(SwapStrategy.unstable)(channelIndex);
            if(user.channels.length == 0)
                _users.remove(nickStr);
        }

        debug(IrcTracker)
        {
            write("checking... ");
            checkIntegrity();
            writeln("done.");
        }
    }

    void onPart(IrcUser user, in char[] channelName)
    {
        if(user.nickName == client.nickName)
            onMeLeave(channelName);
        else
            onLeave(channelName, user.nickName);
    }

    void onKick(IrcUser kicker, in char[] channelName, in char[] nick, in char[] comment)
    {
        debug(IrcTracker) writefln(`%s kicked %s: %s`, kicker.nickName, nick, comment);
        if(nick == client.nickName)
            onMeLeave(channelName);
        else
            onLeave(channelName, nick);
    }

    void onQuit(IrcUser user, in char[] comment)
    {
        debug(IrcTracker)
        {
            writefln("%s quit", user.nickName);
            checkIntegrity();
        }

        string nickStr = user.nickName.to!string;
        if (nickStr in _users)
        {
            auto userInSet = _users[nickStr];
            foreach(channelName; userInSet.channels)
            {
                debug(IrcTracker) writefln("%s left %s by quitting", user.nickName, channelName);
                _channels[channelName]._users.remove(nickStr);
            }

            _users.remove(nickStr);
        }

        debug(IrcTracker)
        {
            write("checking... ");
            checkIntegrity();
            writeln("done.");
        }
    }

    void onNickChange(IrcUser user, in char[] newNick)
    {
        debug(IrcTracker)
        {
            writefln("%s changed nick to %s", user.nickName, newNick);
            checkIntegrity();
        }

        string oldNickStr = user.nickName.to!string;
        if (oldNickStr in _users)
        {
            auto userInSet = _users[oldNickStr];
            _users.remove(oldNickStr);

            string newNickStr = newNick.to!string;
            userInSet.nickName = newNickStr;
            _users[newNickStr] = userInSet;
        }

        debug(IrcTracker)
        {
            write("checking... ");
            checkIntegrity();
            writeln("done.");
        }
    }

    // NEW: Handle mode changes
    void onModeChange(in char[] channel, in char[] modeString, in char[][] params)
    {
        if (channel.length == 0 || channel[0] != '#') return;

        debug (IrcTracker) writefln("Mode change on %s: %s %s", channel, modeString, params);

        size_t paramIdx = 0;
        bool adding = true;

        foreach (char c; modeString)
        {
            if (c == '+') { adding = true; continue; }
            if (c == '-') { adding = false; continue; }

            // Check if this is a prefix mode
            if (c in modeToPrefix)
            {
                char prefix = modeToPrefix[c];

                // Get target user
                string target;
                if (paramIdx < params.length)
                {
                    target = params[paramIdx].to!string;
                    paramIdx++;
                }
                else
                {
                    // No more parameters, use last one
                    if (params.length > 0)
                    {
                        target = params[params.length - 1].to!string;
                    }
                    else
                    {
                        continue;
                    }
                }

                string channelStr = channel.to!string;
                if (auto chan = channelStr in _channels)
                {
                    if (auto userPtr = target in chan._users)
                    {
                        auto user = *userPtr;
                        if (adding)
                        {
                            // Add the prefix
                            user.addPrefix(channelStr, prefix);
                        }
                        else
                        {
                            // Remove the prefix
                            user.removePrefix(channelStr, prefix);
                        }
                    }
                }
            }
            else
            {
                // Non-prefix mode - advance parameter index
                if (paramIdx < params.length)
                {
                    paramIdx++;
                }
            }
        }
    }

    alias eventHandlers = TypeTuple!(onConnect, onSuccessfulJoin, onNameList, onJoin, onPart, onKick, onQuit, onNickChange
    );

    // Start tracking functions
    void onMyChannelsReply(in char[] nick, in char[][] channels)
    {
        if(nick != client.nickName)
            return;

        _client.onWhoisChannelsReply.unsubscribeHandler(&onMyChannelsReply);
        _client.onWhoisEnd.unsubscribeHandler(&onWhoisEnd);

        if(_isTracking != State.starting)
            return;

        startNow();

        foreach(channel; channels)
            onSuccessfulJoin(channel);

        _client.queryNames(channels);
    }

    void onWhoisEnd(in char[] nick)
    {
        if(nick != client.nickName)
            return;

        // Weren't in any channels.

        _client.onWhoisChannelsReply.unsubscribeHandler(&onMyChannelsReply);
        _client.onWhoisEnd.unsubscribeHandler(&onWhoisEnd);

        if(_isTracking != State.starting)
            return;

        startNow();
    }

    private void startNow()
    {
        assert(_isTracking != State.enabled);

        foreach(handler; eventHandlers)
            mixin("client." ~ __traits(identifier, handler)) ~= &handler;

        auto thisNick = _client.nickName.to!string;
        thisUser = new CustomTrackedUser!Payload(thisNick);
        thisUser.userName = _client.userName.to!string;
        thisUser.realName = _client.realName.to!string;
        _users[thisNick] = thisUser;

        _isTracking = State.enabled;
    }

    public:
    this(IrcClient client)
    {
        this._client = client;

        // NEW: Subscribe to mode change events
        client.onModeChange ~= &onModeChange;
    }

    ~this()
    {
        stop();
    }

    /**
     * Initiate or restart tracking, or do nothing if the tracker is already tracking.
     *
     * If the associated client is unconnected, tracking starts immediately.
     * If it is connected, information about the client's current channels will be queried,
     * and tracking starts as soon as the information has been received.
     */
    void start()
    {
        if(_isTracking != State.disabled)
            return;

        if(_client.connected)
        {
            _client.onWhoisChannelsReply ~= &onMyChannelsReply;
            _client.onWhoisEnd ~= &onWhoisEnd;
            _client.queryWhois(_client.nickName);
            _isTracking = State.starting;
        }
        else
            startNow();
    }

    /**
     * Stop tracking, or do nothing if the tracker is not currently tracking.
     */
    void stop()
    {
        final switch(_isTracking)
        {
            case State.enabled:
                _users = null;
                thisUser = null;
                _channels = null;
                foreach(handler; eventHandlers)
                    mixin("client." ~ __traits(identifier, handler)).unsubscribeHandler(&handler);
                break;
            case State.starting:
                _client.onWhoisChannelsReply.unsubscribeHandler(&onMyChannelsReply);
                _client.onWhoisEnd.unsubscribeHandler(&onWhoisEnd);
                break;
            case State.disabled:
                return;
        }

        _isTracking = State.disabled;
    }

    /// Boolean whether or not the tracker is currently tracking.
    bool isTracking() const @property @safe pure nothrow
    {
        return _isTracking == State.enabled;
    }

    /// $(DPREF _client, IrcClient) that this tracker is tracking for.
    inout(IrcClient) client() inout @property @safe pure nothrow
    {
        return _client;
    }

    /**
     * $(D InputRange) (with $(D length)) of all _channels the associated client is currently
     * a member of.
     * Throws:
     *    $(MREF IrcTrackingException) if the tracker is disabled or not yet ready
     */
    auto channels() @property
    {
        import std.range : takeExactly;
        enforce(_isTracking, "not currently tracking");
        return _channels.byValue.takeExactly(_channels.length);
    }

    unittest
    {
        import std.range;
        static assert(isInputRange!(typeof(CustomIrcTracker.init.channels)));
        static assert(is(ElementType!(typeof(CustomIrcTracker.init.channels)) : CustomTrackedChannel!Payload));
        static assert(hasLength!(typeof(CustomIrcTracker.init.channels)));
    }

    /**
     * $(D InputRange) (with $(D length)) of all _users currently seen by the associated client.
     *
     * The range includes the user for the associated client. Users that are not a member of any
     * of the channels the associated client is a member of, but have sent a private message to
     * the associated client, are $(I not) included.
     * Throws:
     *    $(MREF IrcTrackingException) if the tracker is disabled or not yet ready
     */
    auto users() @property
    {
        import std.algorithm : map;
        import std.range : takeExactly;
        enforce(_isTracking, "not currently tracking");
        return _users.byValue.takeExactly(_users.length);
    }

    unittest
    {
        import std.range;
        static assert(isInputRange!(typeof(CustomIrcTracker.init.users)));
        static assert(is(ElementType!(typeof(CustomIrcTracker.init.users)) == CustomTrackedUser!Payload*));
        static assert(hasLength!(typeof(CustomIrcTracker.init.users)));
    }

    /**
     * Lookup a channel on this tracker by name.
     *
     * The channel name must include the channel name prefix. Returns $(D null)
     * if the associated client is not currently a member of the given channel.
     * Params:
     *    channelName = name of channel to lookup
     * Throws:
     *    $(MREF IrcTrackingException) if the tracker is disabled or not yet ready
     * See_Also:
     *    $(MREF TrackedChannel)
     */
    CustomTrackedChannel!Payload* findChannel(in char[] channelName)
    {
        enforce(_isTracking, "not currently tracking");
        return channelName.to!string in _channels;
    }

    /**
     * Lookup a user on this tracker by nick name.
     *
     * Users are searched among the members of all channels the associated
     * client is currently a member of. The set includes the user for the
     * associated client.
     * Params:
     *    nickName = nick name of user to lookup
     * Throws:
     *    $(MREF IrcTrackingException) if the tracker is disabled or not yet ready
     * See_Also:
     *    $(MREF TrackedUser)
     */
    CustomTrackedUser!Payload* findUser(in char[] nickName)
    {
        enforce(_isTracking, "not currently tracking");
        if(auto user = nickName.to!string in _users)
            return *user;
        else
            return null;
    }

    /**
     * Get highest prefix for user in channel ('\0' = none)
     * This is the public method that should be called from client code.
     */
    char getPrefix(in char[] channel, in char[] nick) const
    {
        enforce(_isTracking, "not currently tracking");

        string nickStr = nick.to!string;
        string channelStr = channel.to!string;

        if (auto userPtr = nickStr in _users)
        {
            auto user = *userPtr;
            return user.getHighestPrefix(channelStr);
        }
        else
        {
            // Try case-insensitive search
            foreach (storedNick, userPtr; _users)
            {
                if (toUpper(storedNick) == toUpper(nickStr))
                {
                    auto user = *userPtr;
                    return user.getHighestPrefix(channelStr);
                }
            }
        }

        return '\0';
    }
}

/// Ditto
alias IrcTracker = CustomIrcTracker!void;

